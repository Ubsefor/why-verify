# Task 4

## Build

### Build:

```sh
make all
```

### Build with coverage:

```sh
make cov
```

## Run:

### Run:

```sh
make run
```

### Run with coverage:

```sh
make run-cov
```

### Run with valgrind:

```sh
make valgrind
```

### Valgrind with *--leak-check=full*:

```sh
make leak
```

## Coverage:

### Run lcov and collect coverage:

```sh
make gcov
```

## Clean:

```sh
make clean
```

# Вариант А

## Формальная спецификация.

### Для типов данных:

a) Формальная спецификация структуры Map:

a1) Структура может хранить лишь единственное отображение для конкретного ключа (нет одинаковых ключей).

a2) map->items структуры Map представляет собой массив длины map->capacity.

a3) map->count == количеству элементов items с полем existent == 1.

a4) При работе со структурой учитываются те и только те записи массива items,

которые имеют поле item->existent установленным в истину (item->existent == 1).

a5) 0 <= map->count <= map->capacity – количество "занятых" отображений меньше размера массива этих отображений

a6) Отображения в map->items могут храниться с пропусками; При этом за двумя последовательно идущими элементами,

у которых item->existent установлено в ложь, остальные элементы тоже имеют item->existent установленным в ложь

a7) Элементы map->items хранятся с начала массива.

b) Формальная спецификация структуры Item:

// (b0 Item – структура, содержащая поле existent и пару значений: структуры Key и Value)

b1) Поле existent может принимать значения 0 или 1 (false или true соответственно).

b2) При item->existent == 0 содержимое остальных полей не учитывается при работе с структурой Map

c) Формальная спецификация структуры Key:

c1) Есть два поля размера int: key->a и key->b

d) Формальная спецификация структуры Value:

d1) Есть два поля размера int: value->c и value->d

### Для функций: (finalizeMap, removeElement, getElement)

#### A. finalizeMap:

A1) Функция finalizeMap() освобождает динамическую память, используемую для ассоциативного массива map

A2) На вход функции должен подаваться указатель на область памяти, проинициализированную функцией initializeMap()

(на валидную структуру Map)

A3) После работы функции map->items == NULL

A4) После работы функции map->items освобожден

A5) После работы функции структура map по указателю – не валидная

A6) Переданный функции указатель на память не портится

A7) Функция ничего не аллоцирует

A8) Функция не трогает count и capacity (норм, поскольку мапа все равно не валидная становится)

#### B. removeElement:

B1) Функция removeElement() удаляет сохранённое в ассоциативном массиве map значение по заданному ключу key (если оно там было) // после работы функции ключа нет в любом случае

B2) Функция не удаляет другие отображения // после работы функции элементы остались как были

B3) Функция не добавляет новые отображения. // после работы функции не появилось новых

B4) Функция возвращает истину (единицу), если функция изменила ассоциативный массив, ложь (ноль) в противном случае.

B5) Если переданный value != NULL ==> туда пишется значение удаленного отображения

B6) Функция имеет право изменять структуру ассоциативного массива, если это не отражается на содержащихся в нём парах.

// все существовавшие до удаления отображения (кроме удаляемого) остаются в массиве

B7) Ничего другого функция не делает.

// не освобождает память, не меняет существующие отображения... см B6

B8) map->count-- если элемент был удален или map->count остался таким же, если ничего не удалилось

B9) map->capacity остался таким же

B10) указатели на map и map->items не портятся, память не перевыделяется и не освобождается

B11) Переданные в функцию значения – валидные (map валидный, key валидный, value валидный или NULL)

#### C. getElement:

C1) Функция getElement() возвращает по указателю value сохранённое в ассоциативном массиве map значение для заданного ключа key

C2) и возвращает истину (единицу), если заданный ассоциативный массив имеет отображения для заданного ключа.

C3) В случае, если значение по заданному ключу не содержится в отображении, возвращается ложь (ноль) и ничего другого не происходит.

C4) Функция не меняет ассоциативный массив

// все существовавшие отображения остаются в массиве

C5) и переданный ключ.

// key не перетирается и не меняется

C6) map->capacity не меняется

C7) map->count не меняется

С8) map остается валидным

C9) Переданные в функцию значения – валидные (map валидный, key валидный, value – указатель на валидную память), остаются валидными

// ничего другого функция не делает

С10) Функции передается на вход валидный map,

C11) Ничего не выделяет

С12) ничего не освобождает